---
produce:
    html: 
        remove_answers: false
---

[TOC]

# Travaux Pratiques : Introduction √† la Programmation Orient√©e Objet en Java - Cr√©ation d'un RPG

## Introduction

Dans le cadre de ce projet de travaux pratiques, nous allons explorer les bases de la programmation orient√©e objet (POO) en Java en d√©veloppant un jeu de r√¥le (RPG) simple. L'objectif est d'introduire progressivement les concepts fondamentaux de la POO tout en cr√©ant un programme que vous pouvez vous approprier pour le rendre plus ou moins int√©ressant.

## Objectifs

- Comprendre les principes de base de la programmation orient√©e objet.
- Apprendre √† d√©clarer des variables en Java.
- Utiliser les entr√©es utilisateur pour interagir avec le programme.
- Afficher des donn√©es √† l'√©cran.
- Progresser √©tape par √©tape dans la conception et l'impl√©mentation d'un RPG en Java.

## Instructions

### √âtape 1 : D√©claration de variables et saisie du nom du personnage

Dans cette premi√®re √©tape, vous allez cr√©er un programme Java simple qui permet √† l'utilisateur de saisir le nom de son personnage pour un jeu de r√¥le (RPG) et d'afficher ce nom √† l'√©cran.

**Instructions :**

1. D√©marrez votre environnement de d√©veloppement Java.
2. Cr√©ez une nouvelle classe Java appel√©e "PersonnageRPG".
3. Dans la classe "PersonnageRPG", d√©clarez une variable de type String pour stocker le nom du personnage.
4. √Ä l'int√©rieur de la m√©thode principale (main), utilisez un objet Scanner pour permettre √† l'utilisateur de saisir le nom de son personnage.
5. Affichez ensuite le nom du personnage √† l'√©cran.

**Exemple de code :**

```java
import java.util.Scanner;

public class PersonnageRPG {
    public static void main(String[] args) {
        // D√©claration de la variable pour stocker le nom du personnage
        String nomPersonnage;

        // Cr√©ation d'un objet Scanner pour la saisie utilisateur
        Scanner scanner = new Scanner(System.in);

        // Demande √† l'utilisateur de saisir le nom du personnage
        System.out.print("Entrez le nom de votre personnage : ");
        nomPersonnage = scanner.nextLine();

        // Affiche le nom du personnage √† l'√©cran
        System.out.println("Le nom de votre personnage est : " + nomPersonnage);

        // Ferme le scanner
        scanner.close();
    }
}
```

> N'h√©sitez pas √† vous familiariser avec l'auto-compl√©tion et √† appr√©hender votre IDE. Le Java est un langage assez verbeux, de plus nous allons *√† outrance* faire des choses r√©p√©titives pour aborder les concepts. Si vous d√©couvrez comment tirer profit de l'outil au maximum et que vous comprenez ce qu'il se passe, vous pourriez gagner un temps pr√©cieux.

**Conseils :**
- Familiarisez-vous avec les points d'arr√™t si vous les d√©couvrez.
- [Run and Debug Java in Visual Studio Code](https://code.visualstudio.com/docs/java/java-debugging)

6. Faites en sorte que l'utilisateur soit invit√© √† saisir un nom √† son personnage tant que la longueur de la variable nom est inf√©rieure √† 3.

### √âtape 2 : Cr√©ation de nouvelles variables pour les caract√©ristiques du personnage

Dans cette √©tape, vous allez cr√©er de nouvelles variables pour repr√©senter les caract√©ristiques principales de votre personnage dans un RPG, telles que la force, l'agilit√© et l'intelligence. Vous utiliserez un switch case pour choisir quelles caract√©ristiques augmenter √† l'aide des points de comp√©tence.

**Instructions :**

1. Ajoutez trois nouvelles variables de type int dans votre classe "PersonnageRPG" pour repr√©senter la force, l'agilit√© et l'intelligence du personnage.
2. Initialisez ces variables √† z√©ro au d√©but du programme.
3. Demandez √† l'utilisateur de r√©partir 25 points de comp√©tence entre ces caract√©ristiques en utilisant un switch case pour choisir quelle caract√©ristique augmenter.
4. Assurez-vous que le total des points attribu√©s ne d√©passe pas 25.
5. Si le total des points attribu√©s est n√©gatif ou d√©passe 25, lancez une exception pour indiquer une erreur.

**Conseils :**

- Assurez-vous de comprendre comment fonctionne le switch case pour g√©rer diff√©rents choix de l'utilisateur.
- Utilisez des conditions (if/else) pour v√©rifier si les points attribu√©s sont valides et pour lancer des exceptions si n√©cessaire.
- Testez votre programme avec diff√©rentes r√©partitions de points pour vous assurer qu'il fonctionne correctement.

6. √âquilibrez votre jeu, on veut √©viter que le personnage soit une brute avec 25 de force et 0 en agilit√© et intelligence. On veut un minimum de 3 points dans chaque comp√©tence et pas plus de 15 points par comp√©tence. Vous avez deux solutions : soit vous initialisez les variables √† 3 et vous consid√©rez qu'il n'y a plus que 16 points √† attribuer, soit vous faites en sorte que l'utilisateur choisisse un chiffre compris entre 3 et 15 en lui affichant un message en cas de saisie incorrecte. On pr√©f√®rera la deuxi√®me option car elle vous apprend √† lever une exception :
`throw new IllegalArgumentException("L'agilit√© doit √™tre entre 3 et 15.");`

7. Votre code ressemble √† √ßa au moment d'attribuer les points :

```java
// ...existing code...
// R√©partition des points de comp√©tence
int pointsRestants = 25;
while (pointsRestants > 0) {
    System.out.println("Points restants √† r√©partir : " + pointsRestants);
    System.out.println("1. Augmenter la force");
    System.out.println("2. Augmenter l'agilit√©");
    System.out.println("3. Augmenter l'intelligence");
    System.out.print("Choisissez une caract√©ristique √† am√©liorer (1-3) : ");
    int choix = scanner.nextInt();

    switch (choix) {
        case 1:
            System.out.print("Combien de points voulez-vous ajouter √† la force : ");
            int pointsForceAAttribuer = scanner.nextInt();
            if (pointsForceAAttribuer > pointsRestants) {
                throw new IllegalArgumentException("Le nombre de points attribu√©s est sup√©rieur au nombre de points restants");
            }
            int nouveauSoldePointForce = force + pointsForceAAttribuer;
            if (nouveauSoldePointForce < 3 || nouveauSoldePointForce > 15) {
                throw new IllegalArgumentException("Le nombre de points n'est pas compris entre 3 et 15");
            }
            force = nouveauSoldePointForce;
            pointsRestants -= pointsForceAAttribuer;
            break;
        // ...existing code...
    }
    // ...existing code...
}
```

>Lancez le programme et essayez d'attribuer 20 points d'agilit√©, vous aurez l'erreur suivante :

8. Adaptez votre code pour introduire `try{} catch{}`. Exemple :

```java
while (pointsRestants > 0) {
    try {
        System.out.println("Points restants √† r√©partir : " + pointsRestants);
        System.out.println("1. Augmenter la force");
        System.out.println("2. Augmenter l'agilit√©");
        System.out.println("3. Augmenter l'intelligence");
        System.out.print("Choisissez une caract√©ristique √† am√©liorer (1-3) : ");
        int choix = scanner.nextInt();

        switch (choix) {
            case 1:
                // Reste du code
                throw new IllegalArgumentException("Le nombre de points n'est pas compris entre 3 et 15");
            break;
        }
    } catch (Exception e) {
        System.err.println("\033[0;31m" + e.getMessage() + "\033[0m");
    }
}
```

> Ne pr√™tez pas trop attention aux caract√®res bizarres dans le catch. Cela permet de changer la couleur de la console pour afficher l'erreur en rouge.

Ainsi, lorsque vous ferez une mauvaise saisie, le message d'erreur s'affichera et vous devrez recommencer jusqu'√† avoir correctement attribu√© tous vos points.

>**Vous remarquez que le code commence √† devenir r√©p√©titif pour 4 pauvres variables. On va alors essayer de transformer ce code en programme orient√© objet.**

### √âtape 3 : Cr√©ation de la classe `Personnage`

1. Cr√©ez une nouvelle classe `Personnage` dans le fichier `Personnage.java` qui contiendra les attributs et les m√©thodes pour repr√©senter un personnage dans le RPG.

```java
public class Personnage {
    private String nom;
    private int force;
    private int agilite;
    private int intelligence;

    // Constructeur
    public Personnage(String nom) {
        this.nom = nom;
        this.force = 0;
        this.agilite = 0;
        this.intelligence = 0;
    }

    // Getters
    public String getNom() {
        return nom;
    }

    public int getForce() {
        return force;
    }

    public int getAgilite() {
        return agilite;
    }

    public int getIntelligence() {
        return intelligence;
    }

    // Setters avec v√©rifications

    public void augmenterIntelligence(int intelligenceAAjouter) {
        int nouvelleIntelligence = intelligenceAAjouter + intelligence;
        if (nouvelleIntelligence < 3 || nouvelleIntelligence > 15) {
            throw new IllegalArgumentException("L'intelligence doit √™tre entre 3 et 15.");
        }
        this.intelligence = nouvelleIntelligence;
    }
    // ... Faites pareil pour Agilit√© et Force
}
```

#### √âtape 3.1 : Utilisation de la classe `Personnage` dans le programme principal

Dans votre programme principal, utilisez la classe `Personnage` pour cr√©er un personnage et utilisez ses m√©thodes pour acc√©der et modifier ses caract√©ristiques.

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Demande √† l'utilisateur de saisir le nom du personnage (au moins 3 caract√®res)
        String nomPersonnage = "";
        while (nomPersonnage.length() < 3) {
            System.out.print("Entrez le nom de votre personnage (au moins 3 caract√®res) : ");
            nomPersonnage = scanner.nextLine();
        }

        // Cr√©ation d'un objet Personnage
        Personnage personnage = new Personnage(nomPersonnage);

        // R√©partition des points de comp√©tence
        int pointsRestants = 25;
        while (pointsRestants > 0) {
            try {
                System.out.println("Points restants √† r√©partir : " + pointsRestants);
                System.out.println("1. Augmenter la force");
                System.out.println("2. Augmenter l'agilit√©");
                System.out.println("3. Augmenter l'intelligence");
                System.out.print("Choisissez une caract√©ristique √† am√©liorer (1-3) : ");
                int choix = scanner.nextInt();

                switch (choix) {
                    case 1:
                        System.out.print("Combien de points voulez-vous ajouter √† la force (entre 3 et 15) : ");
                        int pointsForceAAttribuer = scanner.nextInt();
                        personnage.augmenterForce(pointsForceAAttribuer);
                        pointsRestants -= pointsForceAAttribuer;
                        break;
                    case 2:
                        System.out.print("Combien de points voulez-vous ajouter √† l'agilit√© (entre 3 et 15) : ");
                        int pointsAgiliteAAttribuer = scanner.nextInt();
                        personnage.augmenterAgilite(pointsAgiliteAAttribuer);
                        pointsRestants -= pointsAgiliteAAttribuer;
                        break;
                    case 3:
                        System.out.print("Combien de points voulez-vous ajouter √† l'intelligence (entre 3 et 15) : ");
                        int pointsIntelligenceAAttribuer = scanner.nextInt();
                        personnage.augmenterIntelligence(pointsIntelligenceAAttribuer);
                        pointsRestants -= pointsIntelligenceAAttribuer;
                        break;
                    default:
                        System.out.println("Choix invalide, veuillez choisir une option valide !");
                }
            } catch (Exception e) {
                System.err.println("\033[0;31m" + e.getMessage() + "\033[0m");
            }
        }

        // Affichage des caract√©ristiques du personnage
        System.out.println("Nom du personnage : " + personnage.getNom());
        System.out.println("Force : " + personnage.getForce());
        System.out.println("Agilit√© : " + personnage.getAgilite());
        System.out.println("Intelligence : " + personnage.getIntelligence());

        scanner.close();
    }
}
```

> Vous remarquez une erreur en compilant votre code. En Java, le nom du fichier doit respecter le nom de la classe qu'il contient et il ne doit y avoir qu'une seule classe par fichier. Vous remarquez que la petite ampoule üí° vous propose de corriger √ßa √† votre place.

**Observations :**

- La classe `Personnage` encapsule maintenant les donn√©es et les op√©rations li√©es √† un personnage, am√©liorant ainsi la lisibilit√© et la maintenance du code.
- Les v√©rifications des valeurs des caract√©ristiques sont d√©sormais effectu√©es dans les setters de la classe `Personnage`, ce qui renforce le principe d'encapsulation et garantit l'int√©grit√© des donn√©es.

### √âtape 4 : Ajout de comp√©tences au personnage

Dans cette √©tape, vous allez √©tendre les caract√©ristiques du personnage en ajoutant des comp√©tences telles que la perception, l'endurance, le charisme et la chance. Au lieu de cr√©er des getters et des setters pour chaque comp√©tence, vous allez stocker ces informations dans un dictionnaire pour simplifier votre code.

**Instructions :**

1. Ajoutez les comp√©tences suivantes : Perception, Endurance, Charisme, et Chance, en plus des caract√©ristiques d√©j√† existantes. Pour cela, cr√©ez un fichier `Competence.java` et ajoutez le code suivant :

```java
enum Competence {
    FORCE, PERCEPTION, ENDURANCE, CHARISME, INTELLIGENCE, AGILITE, CHANCE;
}
```

2. Nous allons introduire une nouvelle variable que vous ne connaissez pas : `EnumMap`. EnumMap est un dictionnaire dont les cl√©s font partie d'une √©num. En gros, vous pouvez l'imaginer comme un tableau, la premi√®re colonne contient les noms de comp√©tences et la deuxi√®me ce que vous voulez. Toutefois, vous ne voulez pas qu'on puisse √©crire n'importe quoi dans ce tableau. Par exemple `enumMap.put(Competences.FORCE, 1);` c'est OK mais on ne pourra pas √©crire `enumMap.put("toto",1)`.

3. Dans la classe `Personnage`, cr√©ez une m√©thode `augmenterCompetence` pour augmenter le niveau d'une comp√©tence sp√©cifique en v√©rifiant que la nouvelle valeur est comprise entre 3 et 15.

4. Utilisez des exceptions pour signaler une erreur si l'utilisateur entre une valeur incorrecte lors de l'augmentation d'une comp√©tence.

5. Vous pouvez vous d√©barrasser de `augmenterForce`, `augmenterAgilite` et `augmenterIntelligence`.

√Ä ce stade, votre classe Personnage ressemble √† ceci :

```java
import java.util.EnumMap;
import java.util.Map;

public class Personnage {
    private String nom;
    private Map<Competence, Integer> competences;

    // Constructeur
    public Personnage(String nom) {
        this.nom = nom;
        this.competences = new EnumMap<>(Competence.class);
        // Initialisation des comp√©tences avec des valeurs par d√©faut
        initialiserCompetences();
    }

    // M√©thode priv√©e pour initialiser les comp√©tences avec des valeurs par d√©faut
    private void initialiserCompetences() {
        for (Competence competence : Competence.values()) {
            competences.put(competence, 0);
        }
    }

    // M√©thode pour augmenter le niveau d'une comp√©tence
    public void augmenterCompetence(Competence competence, int points) {
        // Effectuez les v√©rifications n√©cessaires
        int nouveauNiveau = competences.get(competence) + points;
        if (nouveauNiveau < 3 || nouveauNiveau > 15) {
            throw new IllegalArgumentException("Le niveau de la comp√©tence doit √™tre entre 3 et 15.");
        }
        competences.put(competence, nouveauNiveau);
    }

    public int getNiveauCompetence(Competence competence) {
        return competences.get(competence);
    }

    // M√©thode pour afficher les comp√©tences du personnage
    public void afficherCompetences() {
        System.out.println("Comp√©tences de " + nom + " :");
        for (Competence competence : Competence.values()) {
            System.out.println(String.format("%-10s \t niveau : %d", competence, getNiveauCompetence(competence)));
        }
    }
}
```

Dans votre code principal :

```java
// ...existing code...
// R√©partition des points de comp√©tence
int pointsRestants = 25;
while (pointsRestants > 0) {
    System.out.println("Points restants √† r√©partir : " + pointsRestants);
    System.out.println("Choisissez une comp√©tence √† am√©liorer : ");
    for (int index = 0; index < Competence.values().length; index++) {
        System.out.println(String.format("%d. %s", index + 1, Competence.values()[index]));
    }

    Integer choixCompetence = scanner.nextInt();
    if (choixCompetence < 1 || choixCompetence > Competence.values().length) {
        throw new IllegalArgumentException("Veuillez choisir un nombre entre 1 et " + Competence.values().length);
    }

    Competence competenceAAugmenter = Competence.values()[choixCompetence - 1];
    System.out.print("Combien de points voulez-vous ajouter √† " + competenceAAugmenter + " (entre 3 et 15) : ");
    int pointsCompetence = scanner.nextInt();

    try {
        personnage.augmenterCompetence(competenceAAugmenter, pointsCompetence);
        pointsRestants -= pointsCompetence;
    } catch (IllegalArgumentException e) {
        System.err.println("\033[0;31m" + e.getMessage() + "\033[0m");
    }
}
```

**Conseils :**

- Utilisez un dictionnaire pour stocker les comp√©tences afin de simplifier la gestion des donn√©es et de rendre votre code plus flexible.
- Utilisez des exceptions pour g√©rer les erreurs lors de l'augmentation des comp√©tences, en veillant √† ce que les valeurs soient comprises entre 3 et 15.

**Illustration de l'avantage de l'encapsulation :**

L'encapsulation permet de regrouper les donn√©es (les comp√©tences du personnage) et les m√©thodes qui agissent sur ces donn√©es (augmenter le niveau d'une comp√©tence) dans une seule entit√©, la classe `Personnage`. Cela rend le code plus modulaire, plus facile √† comprendre et √† maintenir. De plus, en encapsulant les donn√©es, nous pouvons garantir leur int√©grit√© et emp√™cher l'acc√®s direct et non autoris√© √† ces donn√©es de l'ext√©rieur de la classe. Dans notre exemple, si votre personnage gagne un niveau, vous n'aurez qu'√† appeler la m√©thode `augmenterCompetence` et vous n'aurez pas √† refaire toutes les v√©rifications. Aussi, il est impossible sans modifier la classe Personnage de changer la limite de 15 points de comp√©tences. C'est un aspect fondamental en termes de s√©curit√©. Imaginez que votre seule mission est de cr√©er une librairie avec la classe Personnage et que d'autres personnes peuvent cr√©er un jeu, vous √™tes assur√©s qu'ils ne pourront pas la modifier et que le niveau maximum sera toujours de 15.

### √âtape 5 : Mise en place des tests unitaires

Dans cette √©tape, vous allez apprendre √† √©crire des tests unitaires pour v√©rifier le bon fonctionnement de votre classe `Personnage`. Les tests unitaires sont une pratique courante en programmation pour s'assurer que chaque composant d'un programme fonctionne correctement de mani√®re isol√©e.

#### Instructions :

1. **Cr√©ation d'un fichier de test :**

    Dans le r√©pertoire `src/test/java`, cr√©ez un fichier de test pour la classe `Personnage`. Par exemple, cr√©ez un fichier `PersonnageTest.java`.

2. **√âcriture des tests unitaires :**

    Voici un exemple de test unitaire pour la classe `Personnage` :

    ```java
    import org.junit.Test;
    import static org.junit.Assert.*;

    public class PersonnageTest {

        @Test
        public void testAugmenterCompetence() {
            Personnage personnage = new Personnage("Test");
            personnage.augmenterCompetence(Competence.FORCE, 5);
            assertEquals(5, personnage.getNiveauCompetence(Competence.FORCE));
        }

        @Test(expected = IllegalArgumentException.class)
        public void testAugmenterCompetenceInvalide() {
            Personnage personnage = new Personnage("Test");
            personnage.augmenterCompetence(Competence.FORCE, 20);
        }

        @Test
        public void testNomPersonnage() {
            Personnage personnage = new Personnage("Test");
            assertEquals("Test", personnage.getNom());
        }
    }
    ```

3. **Ex√©cution des tests :**

    Pour ex√©cuter les tests, utilisez la commande suivante dans le terminal √† la racine de votre projet :

    ```bash
    gradle test
    ```

    Gradle ex√©cutera les tests et affichera les r√©sultats dans le terminal.

#### Conseils :

- √âcrivez des tests pour chaque m√©thode de votre classe `Personnage` pour vous assurer qu'elles fonctionnent correctement.
- Testez les cas normaux ainsi que les cas d'erreur pour v√©rifier que les exceptions sont correctement lev√©es.
- Utilisez les assertions (`assertEquals`, `assertTrue`, `assertFalse`, etc.) pour v√©rifier les r√©sultats attendus.

> √Ä partir de maintenant, vous devriez √©crire des tests unitaires pour chaque nouvelle fonctionnalit√© que vous ajoutez √† votre programme. Cela vous permettra de d√©tecter rapidement les erreurs et de garantir que votre code fonctionne correctement.

### √âtape 6 : Impl√©mentation de classes de personnages sp√©cialis√©es

Dans cette √©tape, vous allez impl√©menter des classes de personnages sp√©cialis√©es. Vous utiliserez l'h√©ritage pour cr√©er ces classes et surchargerez la m√©thode `attaqueSpeciale()` pour chaque type de personnage.

#### Instructions :

1. Utilisez le diagramme de classes suivant comme guide pour cr√©er les classes de personnages sp√©cialis√©es :

```plantuml
@startuml

abstract class Personnage {
       - nom: String
    - pointsDeVie: int
    - competences: EnumMap
    + Personnage(nom: String)
    + abstract attaqueSpeciale(): void
    + String getNom()
    + int getPointsDeVie()
    + void augmenterCompetence(Competence, int)
    + int getNiveauCompetence(Competence)
    + void afficherCompetences()
    - void initialiserCompetences()
}

class Mercenaire {
    + Mercenaire(nom: String)
    + attaqueSpeciale(): void
}

class SuperMutant {
    + SuperMutant(nom: String)
    + attaqueSpeciale(): void
}


class Scientifique {
    + Scientifique(nom: String)
    + attaqueSpeciale(): void
}

Personnage <|-- Mercenaire
Personnage <|-- SuperMutant
Personnage <|-- Scientifique

@enduml
```

1. Transformez votre classe `Personnage` en une classe abstraite avec les attributs et les m√©thodes communs √† tous les personnages.
2. Ajouter une m√©thode `public abstract void attaqueSpeciale();`
3. Cr√©ez des classes sp√©cialis√©es `Mercenaire`, `SuperMutant` et `Scientifique` en h√©ritant de la classe `Personnage`.
4. Surchargez la m√©thode `attaqueSpeciale()` dans chaque classe sp√©cialis√©e pour d√©finir le comportement de l'attaque sp√©ciale de chaque type de personnage.
5. Testez vos classes en cr√©ant des instances de chaque type de personnage et en appelant la m√©thode `attaqueSpeciale()`.
6. Dans le constructeur, appelez la m√©thode `super()` pour appeler le constructeur parent qui est cens√© initialiser les comp√©tences √† 0. Apr√®s l'initialisation, dans la classe enfant, ajoutez par exemple `augmenterCompetence(Competence.AGILITE, 5);` ainsi chaque classe de personnage a un avantage par rapport aux autres.

#### Conseils :

- Pour cr√©er une classe avec h√©ritage, utilisez le mot-cl√© `extends` suivi du nom de la classe parente.
- Pour surcharger une m√©thode, d√©clarez une m√©thode avec la m√™me signature dans la classe enfant, mais avec une impl√©mentation diff√©rente.

```java
// Classe Mercenaire
class Mercenaire extends Personnage {
    // Constructeur
    public Mercenaire(String nom) {
        super(nom);
        augmenterCompetence(Competence.AGILITE, 5);
        // Mettez la comp√©tence de votre choix pour illustrer
    }

    // Attaque sp√©ciale du mercenaire
    @Override
    public void attaqueSpeciale() {
        System.out.println(getNom() + " utilise son attaque sp√©ciale : Tir de pr√©cision !");
    }
}
```

### √âtape 7 : Utilisation du polymorphisme

Dans l'√©tape 7, nous allons montrer comment tirer profit du polymorphisme en utilisant les classes sp√©cialis√©es `Mercenaire`, `SuperMutant`, et `Scientifique` dans notre programme principal. Voici un exemple de code :

```java
public class Main {
    public static void main(String[] args) {
        // Cr√©ation d'une liste de personnages
        List<Personnage> personnages = new ArrayList<>();
        
        // Ajout de diff√©rents types de personnages √† la liste
        personnages.add(new Mercenaire("John"));
        personnages.add(new SuperMutant("Gronk"));
        personnages.add(new Scientifique("Dr. Smith"));
        
        // Boucle sur la liste des personnages pour les faire attaquer
        for (Personnage personnage : personnages) {
            System.out.println("Nom du personnage : " + personnage.getNom());
            personnage.attaqueSpeciale();
            personnage.afficherCompetences();
            System.out.println(); // Saut de ligne pour la lisibilit√©
        }
    }
}
```

Dans ce code, nous utilisons une liste de type `Personnage` pour stocker diff√©rents types de personnages : `Mercenaire`, `SuperMutant`, et `Scientifique`. Lorsque nous parcourons la liste des personnages, nous appelons la m√©thode `attaqueSpeciale()`.

Gr√¢ce au polymorphisme, l'appel √† `attaqueSpeciale()` sur chaque objet de la liste d√©clenchera l'impl√©mentation sp√©cifique de cette m√©thode dans la classe concr√®te √† laquelle l'objet appartient. Cela nous permet d'appeler la m√©thode appropri√©e pour chaque type de personnage sans avoir √† conna√Ætre le type exact √† l'avance, ce qui rend notre code plus flexible et extensible.

### √âtape 8 : Ajout d'armes et d'armures au personnage

Dans cette √©tape, nous allons √©tendre la classe `Personnage` pour lui permettre de porter des armes et des armures. Nous allons √©galement cr√©er des classes pour les armes et les armures, qui h√©riteront d'une classe abstraite `Item`.

#### Instructions :

1. Cr√©ez une classe abstraite `Item` avec trois attributs : `description` de type String, `poids` de type double et `prix` de type double.
2. Ajoutez deux sous-classes **abstraites** de `Item` : `Arme` et `Armure`.
3. La classe `Arme` doit avoir un attribut suppl√©mentaire `degats` de type int, repr√©sentant les d√©g√¢ts inflig√©s par l'arme.
4. La classe `Armure` doit avoir un attribut suppl√©mentaire `protection` de type int, repr√©sentant le niveau de protection fourni par l'armure.
5. Modifiez la classe `Personnage` pour lui permettre de porter une arme et/ou une armure. Ajoutez les m√©thodes `equiperArme()` et `equiperArmure()` pour cela.
6. Testez vos classes en cr√©ant des classes d√©riv√©es d'armes et d'armures et quelques instances, en les √©quipant √† un personnage, et en simulant des interactions de combat.

√Ä la fin de cette √©tape, votre classe `Personnage` devrait √™tre capable de porter des armes et des armures, ce qui ajoutera une dimension tactique int√©ressante √† votre RPG.

### √âtape 9 : Gestion de l'inventaire

Dans cette √©tape, nous allons nous concentrer sur la gestion de l'inventaire dans notre jeu RPG, en utilisant les classes Collection de Java pour stocker les objets et en introduisant les interfaces et les comparateurs pour enrichir cette fonctionnalit√©.

#### Partie th√©orique : Interfaces et comparateurs en Java

Avant de commencer √† coder, examinons bri√®vement deux concepts cl√©s que nous allons utiliser :

- **Interfaces en Java :** Une interface est un contrat que les classes peuvent choisir de remplir en impl√©mentant ses m√©thodes. Cela permet de d√©finir un ensemble de comportements sans sp√©cifier comment ils doivent √™tre impl√©ment√©s. Dans notre cas, nous allons cr√©er une interface `IValuable` avec une m√©thode `aPourValeur` pour repr√©senter la valeur des objets.

- **Comparateurs en Java :** Les comparateurs sont des objets qui d√©finissent un ordre total sur des objets. Ils sont utilis√©s pour trier des collections d'objets selon certains crit√®res. Nous allons cr√©er des comparateurs pour trier les objets de l'inventaire en fonction de leur prix, leur poids et leur valeur.

Maintenant que nous avons une compr√©hension de base de ces concepts, passons √† la mise en pratique.

#### Ressources suppl√©mentaires :

- [Interface en Java (Oracle Documentation)](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html)
- [Comparateurs en Java (Oracle Documentation)](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)

#### Instructions :

1. **Cr√©ation de l'interface `IValuable` :**

    Impl√©mentez une interface `IValuable` avec une m√©thode `aPourValeur` qui renvoie la valeur de l'objet. Cette interface sera utilis√©e pour d√©finir le comportement des objets ayant une valeur dans notre jeu.
    [!CAUTION] Je ne parle pas de la valeur "prix" mais pour une arme ce sera ses d√©g√¢ts et pour une protection son niveau de protection.

2. **Utilisation de l'interface dans la classe `Item` :**

    Dans la m√©thode `toString` de la classe `Item`, utilisez l'op√©rateur `instanceof` pour v√©rifier si l'objet impl√©mente l'interface `IValuable`. Si c'est le cas, affichez la valeur de l'objet.

3. **M√©thode `ajouterALInventaire` :**

    Impl√©mentez une m√©thode `ajouterALInventaire` qui ajoute un objet √† l'inventaire. Utilisez une collection de type `Set` pour stocker les objets uniques, en √©vitant les doublons.

4. **Affichage de l'inventaire :**

    Impl√©mentez une m√©thode `afficherInventaire` qui utilise les Streams pour grouper les objets de l'inventaire par le nom de leur classe. Pr√©sentez l'introspection en expliquant comment cela permet d'acc√©der aux m√©tadonn√©es des classes √† l'ex√©cution.

5. **Menu de s√©lection d'affichage :**

    Cr√©ez un menu interactif qui permet aux joueurs de choisir quelle page d'inventaire ils veulent voir. Utilisez les m√©thodes `System.out.println` pour afficher les options et la classe `Scanner` pour lire l'entr√©e de l'utilisateur.

6. **Impl√©mentation des comparateurs :**

    Cr√©ez des comparateurs pour trier les objets en fonction de leur prix, leur poids et leur valeur. Utilisez les interfaces `Comparator` pour d√©finir ces comparateurs.

7. **Tri de l'inventaire :**

    Dans le menu de s√©lection, permettez aux joueurs de choisir le type de tri qu'ils veulent appliquer √† leur inventaire en tapant une lettre suivie d'un num√©ro correspondant au type de comparateur.
    > Vous pouvez utiliser la m√©thode `Collections.sort` pour trier les objets en utilisant les comparateurs.
    Vous pouvez √©galement utiliser les Streams pour trier les objets en fonction de leur valeur (d√©g√¢ts ou protection), de leur poids ou de leur prix.
    Pour cela, stockez les comparateurs dans des variables et utilisez-les ainsi :
    ```java
    Collections.sort(inventaire, comparateur);
    ```

En suivant ces √©tapes, vous allez enrichir votre jeu RPG en permettant aux joueurs de g√©rer efficacement leur inventaire et de personnaliser leur exp√©rience de jeu en fonction de leurs besoins et pr√©f√©rences.

### √âtape 10 : Niveau d'exp√©rience et Points de vie

Avant de passer √† la cr√©ation du syst√®me d'exploration, nous allons ajouter deux nouvelles fonctionnalit√©s importantes √† notre jeu : un niveau d'exp√©rience pour le personnage et des points de vie.

#### Instructions :

1. **Ajout du niveau d'exp√©rience :**

    Ajoutez un attribut `niveauExperience` √† la classe `Personnage` pour suivre le niveau d'exp√©rience du personnage.

2. **Ajout des points de vie :**

    Ajoutez une m√©thode `getPointsDeVie` √† la classe `Personnage` pour repr√©senter les points de vie du personnage.
    Dans un premier temps, le personnage ne perd pas d√©finitivement ses points de vie mais il les r√©cup√®re √† chaque fois qu'il est bless√© √† l'issue d'un combat.
    En l'occurrence, c'est plut√¥t "points de vie max" que vous allez impl√©menter.
    Faites que la m√©thode renvoie `100 + Force * 10`.

### √âtape 11 : Cr√©ation du syst√®me d'exploration

Maintenant que nous avons enrichi notre personnage, nous allons cr√©er un syst√®me d'exploration pour lui permettre de vivre des aventures excitantes et dangereuses !

#### Classe ExplorationGenerator

1. **Cr√©ation de la classe ExplorationGenerator :**

    Cr√©ez une nouvelle classe `ExplorationGenerator` qui exposera une m√©thode `explorer(Personnage)`. Cette m√©thode permettra au personnage de d√©couvrir de nouveaux endroits et d'interagir avec ce qu'il y trouve.

2. **M√©thode `explorer` :**

    Dans la m√©thode `explorer`, g√©n√©rez un nombre al√©atoire. Sur une chance sur 4, appelez la m√©thode `looterUnObjet()`, sinon appelez la m√©thode `combat()`.

3. **M√©thode `combat` :**

    La m√©thode `combat` devra √™tre d√©finie dans l'interface `ICombatGenerator`. Elle prendra en param√®tre le personnage et renverra un boolean indiquant le r√©sultat du combat (victoire ou d√©faite).

4. **M√©thode `looterUnObjet` :**

    La m√©thode `looterUnObjet` devra √™tre d√©finie dans l'interface `ILootGenerator`. Elle prendra √©galement en param√®tre le personnage et renverra un objet `Item`.

5. **Gestion de la victoire :**

    Si le r√©sultat du combat est `true`, c'est-√†-dire que le personnage a remport√© le combat, il y a une chance sur 2 d'appeler la m√©thode `looterUnObjet`. Dans tous les cas, le personnage gagnera de l'exp√©rience.

6. **Interfaces pour la g√©n√©ration :**

    Stockez une r√©f√©rence vers une instance des interfaces `ILootGenerator`, `ICombatGenerator` et `IExperienceGenerator`. Ces interfaces prennent en param√®tre un personnage et renvoient respectivement un objet `Item`, un boolean et un entier.

#### Interfaces pour la g√©n√©ration de loot, de combat et d'exp√©rience

Voici les interfaces et les classes concr√®tes pour g√©n√©rer du loot, g√©rer les combats et calculer l'exp√©rience gagn√©e par le personnage.

##### Interface ILootGenerator :

```java
public interface ILootGenerator {
    Item genererLoot();
}
```

##### Interface ICombatGenerator :

```java
public interface ICombatGenerator {
    boolean combat(Personnage personnage);
}
```

##### Interface IExperienceGenerator :

```java
public interface IExperienceGenerator {
    int calculerExperience(Personnage personnage);
}
```

#### Impl√©mentations des classes :

##### LootGenerator :

```java
import java.util.Random;

public class LootGenerator implements ILootGenerator {
    private Random random;

    public LootGenerator() {
        this.random = new Random();
    }

    @Override
    public Item genererLoot() {
        int choix = random.nextInt(6); // G√©n√®re un nombre al√©atoire entre 0 et 5
        // Vous pouvez vous amuser √† rendre les √©quipements plus durs √† obtenir que d'autres, vous pouvez fonctionner avec des plages de valeurs. Exemple : si <50 loot pourri, si <60 moyen, si <70 bon loot, etc. Par contre, il ne sera pas possible d'utiliser un switch case.

        switch (choix) {
            case 0:
                return new ArmureCuir();
            case 1:
                return new ArmureTissu();
            case 2:
                return new ArmureMetal();
            case 3:
                return new ArmureCombat();
            case 4:
                return new ArmureEnergetique();
            case 5:
                return new ArmureAssault();
            default:
                // En cas de choix invalide, retourne null
                return null;
        }
    }
}
```

##### CombatGenerator :

```java
public class CombatGenerator implements ICombatGenerator {
    private Random random;

    public CombatGenerator() {
        this.random = new Random();
    }

    @Override
    public boolean combat(Personnage personnage) {
        // Points de vie du monstre entre 50 et 100
        int pointsDeViePersonnage = personnage.getPointsDeVie();

        int pointsDeVieMonstre = pointsDeViePersonnage * random.nextDouble(0.9,1.2); // Points de vie du monstre entre 90 et 120% de ceux du personnage
    
        do {
            // Calcul des d√©g√¢ts inflig√©s par le personnage et le monstre
            int degatsPersonnage = personnage.getDegats() + random.nextInt(11); // D√©g√¢ts entre 0 et 10 suppl√©mentaires
            int degatsMonstre = degatsPersonnage * random.nextDouble(0.9,1.2); // D√©g√¢ts du monstre entre 90 et 120% de ceux du personnage

            // Appliquer les d√©g√¢ts
            pointsDeVieMonstre -= degatsPersonnage;
            pointsDeViePersonnage -= degatsMonstre;

            // V√©rifier si le combat est termin√©
            if (pointsDeVieMonstre <= 0) {
                // Le personnage a gagn√©
                return true;
            } else if (pointsDeViePersonnage <= 0) {
                // Le monstre a gagn√©
                return false;
            }
        } while (pointsDeVieMonstre > 0 && pointsDeViePersonnage > 0);

        // Ce cas ne devrait normalement pas √™tre atteint
        return false;
    }
}
```

##### ExperienceGenerator :

```java
public class ExperienceGenerator implements IExperienceGenerator {
    @Override
    public int calculerExperience(Personnage personnage) {
        int intelligence = personnage.getIntelligence();
        int chance = personnage.getChance();
        
        // Calcul de l'exp√©rience en fonction de l'intelligence et de la chance du personnage
        return (intelligence * 10) + (chance * 5);
    }
}
```

7. **Am√©lioration du g√©n√©rateur de combat**

    1. Vous remarquerez que la protection du personnage et les d√©g√¢ts de son arme ne rentrent pas en compte. C'est √† vous d'am√©liorer cette m√©thode pour qu'elle prenne en compte ces param√®tres.
    2. Rappelez-vous que votre personnage a une comp√©tence attaque sp√©ciale, vous pouvez l'utiliser pour augmenter les d√©g√¢ts inflig√©s par le personnage.
    3. Vous pouvez √©galement jouer davantage avec la comp√©tence Chance du personnage.
    4. Ajoutez des sorties consoles pour la m√©thode de combat pour que le joueur puisse suivre le combat.
    6. Impl√©mentez une m√©thode gainExperience dans la classe Personnage pour ajouter de l'exp√©rience au personnage. Cette m√©thode prendra en param√®tre un entier repr√©sentant le nombre de points d'exp√©rience √† ajouter au personnage. Comparez l'ancienne valeur et la nouvelle, si le personnage a gagn√© un niveau, il pourra augmenter une comp√©tence de son choix.
    [!NOTE] Pour d√©tecter un changement de niveau, soit vous pouvez le faire de mani√®re lin√©aire (tous les 100 points d'exp√©rience par exemple) soit vous pouvez utiliser une formule math√©matique pour calculer le niveau en fonction de l'exp√©rience. Par exemple niveau = experience^0.3 qui donne les paliers suivants :
    >- Niveau 2 : 10
    >- Niveau 3 : 38
    >- Niveau 4 : 101
    >- Niveau 5 : 213


